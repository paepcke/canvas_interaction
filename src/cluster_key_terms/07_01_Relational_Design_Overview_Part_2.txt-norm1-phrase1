 so the basic of idea of what we're going to do is design by decomposition specifically we're going to do what we did at the very beginning of this example which is start by creating mega relations that just contain attributes for everything that we want to represent in our database then we're going to decompose those mega relations into smaller ones that are better but still capture the same information
 and most importantly we can do this decomposition automatically
 so how does automatic decomposition work
 in addition to the mega relations we're going to specify formally properties of the data the system is going to use the properties to decompose the relations and then it's going to guarantee that the final set of relations satisfy what's called a normal form
 and we'll be formalizing all of this
 but the basic idea behind normal forms is that they don't have any of those anomalies that i showed and they don't lose any information
 so specifically for specification of properties we're going to begin by looking at something called functional dependencies
 and once we specify functional dependencies the system will generate relations that are in what's called boyse codd normal form
 and boyse and codd by the way were two early pioneers in relational databases in general
 then we're going to look at another type of specification called multi valued dependencies which will add to functional dependencies and when we have both functional and multi valued dependencies then we can have what's called fourth normal form and again that would be relations that are generated by the system that satisfy the normal form
 boyce codd normal form is stricter than fourth normal form
 specifically if we make a big venn diagram here of all the relational designs that satisfied boyce codd normal form which by the way is very often abbreviated bcnf then that contains all of the relations that satisfy fourth normal form normally abbreviated nf
 so every relation that's in fourth normal form is also in boyce codd normal form but not vice versa
 you might be wondering what happened to first second and third normal forms
 so first normal form is pretty much just a specification that relations are real relations with atomic values in each cell
 second normal form is specifying something about the way relations are structured with respect to their keys
 neither of those is discussed very much anymore
 third normal form is a slight weakening of boyce codd normal form and sometimes people do like to talk about third normal form
 so you can think of third normal form as a little bit of a even bigger circle here
 we're not going to cover third normal form in this video because boyce codd normal form is the most common normal form used if we have functional dependencies only and fourth normal form if we have functional and multivalued dependencies
 so what's going to happen next is i'm going to give some examples to motivate these four concepts functional dependencies boyce codd normal form multivalued dependencies normal form and then later videos will go into each one in much greater depth
 so let me just give the general idea of functional dependencies and boyce codd normal form
 and we'll use a very simple for example an abbreviated version of our apply relation that has students' social security numbers the student's name and their colleges that the student is applying to
 even this small relation actually has redundancy and update and deletion anomalies
 specifically let's say that our student ann applies to colleges
 then there will be tuples and there will be instances where we know that a student with the social security number is named ann
 specifically we're going to store for every student the name and social security number pair once for each college that they apply to
 so now let me explain what a functional dependency is and then we'll see how functional dependencies are used to recognize when we have a bad design like this one and to see how we can fix it
 a functional dependency in this case from social security number to name and we're saying social security number functionally determines the student name says that the same social security number always has the same name
 in other words every time we see we're going to see ann
 now it doesn't necessarily go in the other direction
 it might not be that whenever we see ann it's but whenever we see it is ann
 and so what we'd like to do is store that relationship just one time
 one time say that for the name is ann
 now what boyce codd normal form says is that whenever we have one of these functional dependencies then the left hand side of that functional dependency must be a key
 and think about what that's saying
 remember a key says that we have just one tupple with each value for that attribute
 so if we have say social security number to name as a functional dependency and we satisfy boyce codd normal form then we're going to say that social security number has to be a key in our relation and we'll only have one tupple for each social security number
 specifically we can go back to our original relation
 we have this functional dependency social security number here is not a key right
 so then we know that this is not in boyce codd normal form
 so we're going to use functional dependencies to help us decompose our relation so that the decomposed relations are in boyce codd normal form
 and here's what would happen in this example
 our functional dependency would tell us to pull out the social security number and student name into its own relation where the social security number is a key and then we have just one time for each social security number that students name and then separately we'll have the information about the students and which colleges they applied to
 again we'll completely formalize this whole idea the definition of functional dependencies their properties the normal form and how we do the decomposition in a later video
